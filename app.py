from flask import Flask, request, abort
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import (
    MessageEvent, TextMessage, AudioMessage, TextSendMessage,
    QuickReply, QuickReplyButton, MessageAction
)
import os, tempfile, datetime, requests, random
from dotenv import load_dotenv
from openai import OpenAI

from notion_client import Client

load_dotenv()

NOTION_MEMO_SECRET = os.getenv("NOTION_MEMO_SECRET")  # .env„ÅßÁÆ°ÁêÜ„Åó„Å¶OK
NOTION_MEMO_PAGE_ID = os.getenv("NOTION_MEMO_PAGE_ID")  # .env„ÅßÁÆ°ÁêÜ„Åó„Å¶OK
notion_memo = Client(auth=NOTION_MEMO_SECRET)

app = Flask(__name__)

memo_state = {}  # user_id ‚Üí ÈÄ≤ÊçóÁä∂ÊÖã

def add_memo_to_notion(category, content, subcategory=None):
    if category == "„Ç¢„Ç§„Éá„Ç¢":
        # subcategory„ÅåÊú™ÊåáÂÆö„ÅÆÂ†¥Âêà„ÅØ„Ç®„É©„ÉºÔºàÂàÜÂ≤ê„Åô„Çã„ÅÆ„ÅßÂøÖ„ÅöÊåáÂÆö„Åï„Çå„Çã„ÅØ„ÅöÔºâ
        if not subcategory:
            print("„Ç¢„Ç§„Éá„Ç¢„Å™„ÅÆ„Å´„Çµ„Éñ„Ç´„ÉÜ„Ç¥„É™„ÅåÊú™ÊåáÂÆö„Åß„Åô")
            return
        block_id = CATEGORY_BLOCK_IDS["„Ç¢„Ç§„Éá„Ç¢"].get(subcategory)
    else:
        block_id = CATEGORY_BLOCK_IDS.get(category)
        # „ÇÇ„Åócategory„Åå"„Ç¢„Ç§„Éá„Ç¢"„Å†„Å£„ÅüÂ†¥Âêà„ÅØ„ÄÅ„Åì„Åì„Åßblock_id„Å´ËæûÊõ∏„ÅåÂÖ•„Å£„Å¶„Åó„Åæ„ÅÜ
        if isinstance(block_id, dict):
            print("„Ç´„ÉÜ„Ç¥„É™„Å´ËæûÊõ∏„ÅåÁõ¥Êé•Ê∏°„Åï„Çå„Å¶„ÅÑ„Çã„ÄÇsubcategoryÂøÖÈ†à„Åß„Åô„ÄÇ")
            return
    if not block_id:
        print(f"Êú™Áü•„ÅÆ„Ç´„ÉÜ„Ç¥„É™: {category} {subcategory}")
        return
    text = content  # „Äå„Äê„Ç´„ÉÜ„Ç¥„É™„Äë„Äç„ÅØ‰∏çË¶Å
    notion_memo.blocks.children.append(
        block_id=block_id,
        children=[
            {
                "object": "block",
                "type": "paragraph",
                "paragraph": {
                    "rich_text": [
                        {"type": "text", "text": {"content": text}}
                    ]
                }
            }
        ]
    )

print("[NOTION_REVIEW_DBID]", os.getenv("NOTION_REVIEW_DBID"))  # ‚Üê„Åì„ÅìÔºÅ


# --- Flask„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºà404ÂØæÁ≠ñÔºã„Éá„Éê„ÉÉ„Ç∞Ôºâ ---
@app.route("/", methods=["GET"])
def index():
    return "OK", 200

@app.route("/callback", methods=["POST"])
def callback():
    print("[/callback] POST accessed")
    signature = request.headers.get("X-Line-Signature", "")
    body = request.get_data(as_text=True)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        print("[/callback] InvalidSignatureError")
        abort(400)
    return "OK"

# --- LINE/OPENAI/NOTIONÂêÑÁ®Æ„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó ---
line_bot_api = LineBotApi(os.getenv("LINE_CHANNEL_ACCESS_TOKEN"))
handler      = WebhookHandler(os.getenv("LINE_CHANNEL_SECRET"))
client       = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
NOTION_TOKEN = os.getenv("NOTION_TOKEN")
NOTION_DBID  = os.getenv("NOTION_DBID")

CATEGORY_BLOCK_IDS = {
    "„Ç¢„Ç§„Éá„Ç¢": {
        "‰ªï‰∫ã":      "215476859b9580af8f68c63eab51bc00",
        "„Éó„É©„Ç§„Éô„Éº„Éà": "215476859b95806d8f75c73b6b407c30",
    },
    "ÊÑüÊÉÖ":         "215476859b958088b57bfb1a44944ebb",
    "Ê∞ó„Å•„Åç":       "215476859b9580a3bc10da74aa5dbfe9",
    "Âæå„ÅßË™ø„Åπ„Çã":   "215476859b9580ff8a31ea3a6d348010",
    "„Çø„Çπ„ÇØ":       "215476859b9580dfbf65c9badda314fd",
    "Ë≤∑„ÅÑÁâ©„É™„Çπ„Éà": "215476859b95803fa180e1aab0b99d42",
    "„É™„É≥„ÇØ":       "215476859b95808b8cadd1eb44789038",
}

CLUSTERS = {
    "ÊàêÈï∑Á≥ª":   ["Ë™†ÂÆü„Åï", "Â≠¶„Å≥", "ÂâµÈÄ†ÊÄß", "Ëá™Â∑±ÊàêÈï∑", "Êé¢Á©∂ÂøÉ", "Âêë‰∏äÂøÉ", "Âä™Âäõ"],
    "Èñ¢‰øÇÊÄßÁ≥ª": ["ÊÑõ", "ÂèãÊÉÖ", "ÂÆ∂Êóè", "ÂÖ±ÊÑü", "Ë¶™Âàá", "ÊîØÊè¥", "ÂÖ¨Âπ≥"],
    "ÊåëÊà¶Á≥ª":   ["ÂãáÊ∞ó", "ÂÜíÈô∫", "ÈÅîÊàê", "‰∏ª‰ΩìÊÄß", "„É™„Éº„ÉÄ„Éº„Ç∑„ÉÉ„Éó", "ÊåëÊà¶ÂøÉ"],
    "ÂÆâÂÆöÁ≥ª":   ["ÂÆâÂÆö", "ÂÆâÂøÉ", "Ë¶èÂæã", "Ë≤¨‰ªª", "ÊåÅÁ∂öÊÄß", "Ë™øÂíå", "ÂÆâÂÖ®"],
    "ÂÜÖÈù¢Á≥ª":   ["Ëá™Âæã", "Ëá™Áî±", "ÂÜÖÁúÅ", "Âπ∏Á¶è", "ÊÑüË¨ù", "Á≤æÁ•ûÊàêÈï∑"],
    "ÂÅ•Â∫∑Á≥ª":   ["ÂÅ•Â∫∑", "‰ΩìÂäõ", "Ê¥ªÂäõ", "„Éê„É©„É≥„Çπ", "Èï∑ÂØø", "Ëá™Â∑±ÁÆ°ÁêÜ", "„Ç¶„Çß„É´„Éç„Çπ"],
}
CLUSTER_LABELS = list(CLUSTERS.keys())
MAX_PAIRWISE   = 9

PROP_MAP = {
    "ValueStar":     "Value‚òÖ",
    "ValueReason":   "Value reason",
    "MissionStar":   "Mission‚òÖ",
    "MissionReason": "Mission reason",
    "IfThen":        "If-Then",
    "Tomorrow":      "TomorrowMIT",
    # ...‰ªñÁï•
}


Q1_QUESTIONS = {
    "ÂÅ•Â∫∑":      "ü©∫„ÄêÂÅ•Â∫∑„Äë„Åì„ÅÆ„Åæ„Åæ„ÅÑ„Åè„Å®ÂæåÊÇî„Åó„Åù„ÅÜ„Å™„Åì„Å®„ÅØÔºü„Å©„Çì„Å™‰∫∫Áîü„Å´„Å™„Çä„Åæ„Åô„ÅãÔºü",
    "ÊåëÊà¶ÁµåÈ®ì":  "üöÄ„ÄêÊåëÊà¶„ÉªÁµåÈ®ì„Äë„Åì„ÅÆ„Åæ„Åæ„ÅÑ„Åè„Å®ÂæåÊÇî„Åó„Åù„ÅÜ„Å™„Åì„Å®„ÅØÔºü„Å©„Çì„Å™‰∫∫Áîü„Å´„Å™„Çä„Åæ„Åô„ÅãÔºü",
    "‰∫∫ÈñìÈñ¢‰øÇ":  "ü§ù„Äê‰∫∫ÈñìÈñ¢‰øÇ„Äë„Åì„ÅÆ„Åæ„Åæ„ÅÑ„Åè„Å®ÂæåÊÇî„Åó„Åù„ÅÜ„Å™„Åì„Å®„ÅØÔºü„Å©„Çì„Å™‰∫∫Áîü„Å´„Å™„Çä„Åæ„Åô„ÅãÔºü",
}
LIFE5_QUESTIONS = [
    None,
    None,
    "üåÖ„Äê„Éì„Ç∏„Éß„É≥„Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„Éà„ÄëÊú™Êù•„ÅÆ1„Ç∑„Éº„É≥„Çí30Ë™û‰ª•ÂÜÖ„ÅßÊèèÂÜô„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºàË™∞„Å®„ÄÅ„Å©„Åì„Åß„ÄÅ‰Ωï„Çí„Åó„Å¶„ÄÅ„Å©„Çì„Å™Ê∞óÊåÅ„Å°ÔºüÔºâ",
    "‚ùì„ÄêDeep-Why„ÄëÂè∂„Å£„ÅüÊôÇ„Å´Ê∫Ä„Åü„Åï„Çå„ÇãÊÑüÊÉÖ or Âè∂„Çè„Å™„Åã„Å£„ÅüÊôÇ„Å´Â§±„ÅÜ„ÇÇ„ÅÆ„Çí„ÄÅÊÑüÊÉÖ„Åß1Ë°å„ÅßÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
    "üéØ„Äê‰ªäÊó•„ÅÆ„Éü„ÉÉ„Ç∑„Éß„É≥„Äë2ÊôÇÈñì‰ª•ÂÜÖ„Å´„ÄÅË™∞„Å´ÂØæ„Åó„Å¶„ÄÅ„Å©„Çì„Å™Ë≤¢ÁåÆ„Åå„Åß„Åç„Åù„ÅÜ„Åß„Åô„ÅãÔºü"
]
progress = {}  # uid ‚Üí state dict

# ---------- „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ ----------
def summarize(text: str) -> str:
    prompt = f"‰ª•‰∏ã„Çí200Â≠ó‰ª•ÂÜÖ„ÅßË¶ÅÁ¥Ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n\n{text}"
    try:
        res = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "„ÅÇ„Å™„Åü„ÅØÊó•Êú¨Ë™û„ÅÆË¶ÅÁ¥ÑAI„Åß„Åô„ÄÇ"},
                {"role": "user",   "content": prompt}
            ]
        )
        return res.choices[0].message.content.strip()
    except Exception as e:
        print("[Ë¶ÅÁ¥Ñ„Ç®„É©„Éº]", e)
        return text[:200]

def create_notion_row(user_id, q1_summary):
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    data = {
        "parent": {"database_id": NOTION_DBID},
        "properties": {
            "Date":        {"title":[{"text":{"content":now}}]},
            "UserID":      {"rich_text":[{"text":{"content":user_id}}]},
            "Q1_Summary":  {"rich_text":[{"text":{"content":q1_summary}}]},
            "Q2_Summary":  {"rich_text":[]},
            "Q3_Summary":  {"rich_text":[]},
            "Q4_Summary":  {"rich_text":[]},
            "Q5_Summary":  {"rich_text":[]},
        }
    }
    r = requests.post("https://api.notion.com/v1/pages",
                      headers={
                          "Authorization":f"Bearer {NOTION_TOKEN}",
                          "Content-Type":"application/json",
                          "Notion-Version":"2022-06-28"
                      },
                      json=data)
    print("[Notion create]", r.status_code)
    return r.json().get("id") if r.ok else None

def update_notion_row(page_id, key, value):
    notion_key = PROP_MAP.get(key, key)          # Python „Åß‰Ωø„ÅÜ„Ç≠„Éº ‚Üí Notion ÂàóÂêç
    r = requests.patch(
        f"https://api.notion.com/v1/pages/{page_id}",
        headers={
            "Authorization": f"Bearer {NOTION_TOKEN}",
            "Content-Type":  "application/json",
            "Notion-Version":"2022-06-28",
        },
        json={
            "properties": {
                notion_key: {                 # ‚Üê „Åì„Åì„Çí‰øÆÊ≠£
                    "rich_text": [
                        { "text": { "content": value } }
                    ]
                }
            }
        }
    )
    print("[Notion update]", notion_key, r.status_code, r.text)

def create_review_page(user_id, now):
    data = {
        "parent": {"database_id": os.getenv("NOTION_REVIEW_DBID")},
        "properties": {
            "Date":          {"title": [{"text": {"content": now}}]},
            "UserID":        {"rich_text": [{"text": {"content": user_id}}]},
            "Value‚òÖ":        {"rich_text": []},
            "Value reason":  {"rich_text": []},
            "Mission‚òÖ":      {"rich_text": []},
            "Mission reason":{"rich_text": []},
            "Win":           {"rich_text": []},
            "If-Then":       {"rich_text": []},
            "Pride":         {"rich_text": []},
            "Gratitude":     {"rich_text": []},
            "EmotionTag":    {"rich_text": []},
            "EmotionNote":   {"rich_text": []},
            "Insight":       {"rich_text": []},
            "TomorrowMIT":   {"rich_text": []},
        }
    }
    r = requests.post(
        "https://api.notion.com/v1/pages",
        headers={
            "Authorization": f"Bearer {NOTION_TOKEN}",
            "Content-Type": "application/json",
            "Notion-Version": "2022-06-28",
        },
        json=data,
    )
    print("[Notion review page create]", r.status_code, r.text)
    return r.json().get("id") if r.ok else None

def build_pairs(values: list, n_pairs: int):
    random.shuffle(values)
    idx = list(range(len(values)))
    pairs = [(i, j) for i in idx for j in idx if i < j]
    random.shuffle(pairs)
    return pairs[:n_pairs]

def generate_ai_hint(theme, prev_inputs=None, prev_hints=None):
    # „ÉÜ„Éº„ÉûÂà•„ÅÆ„Éí„É≥„ÉàÁîüÊàê„Éó„É≠„É≥„Éó„ÉàË®≠Ë®à
    if theme == "ÊåëÊà¶ÁµåÈ®ì":
        prompt = (
            "„ÅÇ„Å™„Åü„ÅØ„É¶„Éº„Ç∂„Éº„Åå‰∫∫Áîü„ÅßÊåëÊà¶„Åó„Åü„ÅÑ„Åì„Å®„ÇÑÁµåÈ®ì„Åó„Åü„ÅÑ„Åì„Å®„Å´Ê∞ó„Å•„Åè„Åü„ÇÅ„ÅÆË≥™ÂïèÂÆ∂„Åß„Åô„ÄÇ\n"
            "‰ª•‰∏ã„ÅÆÊù°‰ª∂„Åß„ÄÅÊåëÊà¶„ÉªÁµåÈ®ì„ÉÜ„Éº„Éû„ÅÆÊ∞ó„Å•„Åç„ÇÑËá™Â∑±ÂØæË©±„Å´„Å™„ÇãÂïè„ÅÑ„Åã„Åë„ÇÑ„Éí„É≥„Éà„ÇíÊó•Êú¨Ë™û„Åß1„Å§„Å†„ÅëÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n"
            "„Äê„Åì„Çå„Åæ„Åß„ÅÆÂÖ•Âäõ‰æã„Äë\n"
        )
        if prev_inputs:
            prompt += "\n".join([f"„Éª{x}" for x in prev_inputs if x.strip()]) + "\n"
        if prev_hints:
            prompt += "„Äê„Åì„Çå„Åæ„Åß„ÅÆ„Éí„É≥„Éà„Äë\n"
            prompt += "\n".join([f"„Éª{x}" for x in prev_hints if x.strip()]) + "\n"
        prompt += (
            "„ÄêÂá∫ÂäõË¶Å‰ª∂„Äë\n"
            "- ‰Ωï„Å´ÊåëÊà¶„Åó„Åü„ÅÑ„Åã„ÄÅ„Å©„Çì„Å™ÁµåÈ®ì„ÇíÊú¨ÂΩì„ÅØ„Åó„Åü„ÅÑ„ÅÆ„ÅãËÄÉ„Åà„Çã„Åç„Å£„Åã„Åë„Å´„Å™„Çã„Åì„Å®\n"
            "- „Åü„Å®„Åà„Å∞„ÄåÂ≠ê‰æõ„ÅÆÈ†É„ÅÆÂ§¢„ÅØÔºü„Äç„Äå‰ªä„ÇÑ„Å£„Å¶„Åø„Åü„ÅÑ„Å®ÊÄù„Å£„Å¶„Çã„Åë„Å©ÂÖàÂª∂„Å∞„Åó„Å´„Åó„Å¶„Çã„Åì„Å®„ÅØÔºü„Äç„ÄåÊåëÊà¶„Åó„Åü„ÅÑ„Åë„Å©‰∏ÄÊ≠©Ë∏è„ÅøÂá∫„Åõ„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÅØÔºü„Äç„Äå„ÇÑ„Å£„Å¶„Åø„Åü„Åã„Å£„Åü„Åë„Å©Ë´¶„ÇÅ„Åü„Åì„Å®„ÅØÔºü„Äç„Å™„Å©„ÄÅËá™ÂàÜ„ÅÆ‚Äú„ÇÑ„Çä„Åü„ÅÑ‚Äù„ÇíÊÄù„ÅÑÂá∫„Åï„Åõ„ÇãÂïè„ÅÑ„ÇÑÊ∞ó„Å•„Åç„ÅÆ„Éí„É≥„Éà„Çí1„Å§„Å†„ÅëÂá∫„Åô„ÄÇ\n"
            "- „Å™„Çã„Åπ„ÅèË¢´„Çâ„Å™„ÅÑÂÜÖÂÆπ„ÄÅÁ∞°ÊΩî„Å´1Ë°å„Åß„ÄÇ"
        )
    else:
        prompt = (
            f"„ÅÇ„Å™„Åü„ÅØ‰∫∫Áîü„ÅÆÂæåÊÇî„ÇíÈò≤„Åê„Åü„ÇÅ„ÅÆÊ∞ó„Å•„Åç„ÇÑËá™Â∑±ÂØæË©±„ÅÆ„Éó„É≠Ë≥™ÂïèÂÆ∂„Åß„Åô„ÄÇ\n"
            f"„ÉÜ„Éº„Éû: {theme}\n"
        )
        if prev_inputs:
            prompt += "„Äê„Åì„Çå„Åæ„Åß„ÅÆÂÖ•Âäõ‰æã„Äë\n"
            prompt += "\n".join([f"„Éª{x}" for x in prev_inputs if x.strip()]) + "\n"
        if prev_hints:
            prompt += "„Äê„Åì„Çå„Åæ„Åß„ÅÆ„Éí„É≥„Éà„Äë\n"
            prompt += "\n".join([f"„Éª{x}" for x in prev_hints if x.strip()]) + "\n"
        prompt += (
            "„Åì„Çå„Çâ„Å®ÈáçË§á„Åó„Å™„ÅÑ„ÄÅ„É¶„Éº„Ç∂„Éº„ÅåÊ∑±„ÅèËÄÉ„Åà„Çã„Åç„Å£„Åã„Åë„Å´„Å™„Çã„Çà„ÅÜ„Å™„Éí„É≥„Éà„ÇÑÂïè„ÅÑ„ÇíÊó•Êú¨Ë™û„Åß1„Å§„Å†„Åë„ÄÅ1Ë°å„ÅßÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
        )
    try:
        res = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "„ÅÇ„Å™„Åü„ÅØ‰∫∫Áîü„ÅÆÂïè„ÅÑ„ÇÑÊ∞ó„Å•„Åç„Çí‰∏é„Åà„Çã„Éó„É≠„ÅÆË≥™ÂïèÂÆ∂„Åß„Åô„ÄÇ"},
                {"role": "user",   "content": prompt}
            ]
        )
        # 1Ë°å„Å†„Åë
        return [res.choices[0].message.content.strip().split("\n")[0]]
    except Exception as e:
        print("[„Éí„É≥„ÉàÁîüÊàê„Ç®„É©„Éº]", e)
        return ["Ôºà„Éí„É≥„ÉàÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„ÅüÔºâ"]

# ---------- „É°„Ç§„É≥„É≠„Ç∏„ÉÉ„ÇØ ----------
def life5_flow(uid, text, event, is_audio=False):
    st = progress.setdefault(uid, {})
    # 0) /life5 „Çπ„Çø„Éº„Éà ---------------------------------
    if text.lower() == "/life5":
        st.clear(); st["mode"]="theme"
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=("‰∫∫ÁîüÔºùÊôÇÈñìÔºàÁîü„Åæ„Çå„Å¶„Åã„ÇâÊ≠ª„Å¨„Åæ„ÅßÔºâ\n"
                      "Ê∫ÄË∂≥„Åó„Åü‰∫∫Áîü„ÅßÁµÇ„Çè„Çä„Åü„ÅÑÔºüÂæåÊÇî„Åó„Åü„Åæ„ÅæÔºü\n"
                      "Ê≠ª„Å¨ÈñìÈöõ„ÅÆÂæåÊÇî„Éà„ÉÉ„ÉóÔºì„ÅØ ‚ë†ÂÅ•Â∫∑ ‚ë°ÊåëÊà¶ÁµåÈ®ì ‚ë¢‰∫∫ÈñìÈñ¢‰øÇ\n\n"
                      "‰ªäÊó•„ÅØ„Å©„ÅÆ„ÉÜ„Éº„Éû„ÇíËÄÉ„Åà„ÇãÔºü"),
                quick_reply=QuickReply(items=[
                    QuickReplyButton(action=MessageAction(label=k, text=f"„ÉÜ„Éº„Éû:{k}"))
                    for k in Q1_QUESTIONS.keys()
                ])
            )
        )
        return True
    # 1) „ÉÜ„Éº„ÉûÈÅ∏Êäû --------------------------------------
    if text.startswith("„ÉÜ„Éº„Éû:"):
        theme = text.replace("„ÉÜ„Éº„Éû:", "")
        st.clear()
        st.update(theme=theme, mode="q1", q1_text="", page_id=None, hints=[])
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=Q1_QUESTIONS[theme]))
        return True

    # Q1„Éí„É≥„ÉàÔºàAIÁîüÊàê„ÄÅÈáçË§áÈò≤Ê≠¢‰ªò„ÅçÔºâ
    if text.strip() == "„Éí„É≥„Éà" and st.get("mode") == "q1":
        theme = st.get("theme")
        prev_inputs = [st.get("q1_text", "")]
        prev_hints  = st.get("hints", [])
        new_hint = generate_ai_hint(theme, prev_inputs, prev_hints)[0]
        # Â±•Ê≠¥„Å´ËøΩÂä†
        st.setdefault("hints", []).append(new_hint)
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(text=f"„Éí„É≥„ÉàÔºö\n„Éª{new_hint}")
        )
        return True

    # 2) Q1: ÂæåÊÇî„Ç∑„Éä„É™„Ç™ÂÖ•Âäõ ----------------------------
    if st.get("mode") == "q1":
        st["q1_text"] = text
        q1_summary   = summarize(text)
        page_id      = create_notion_row(uid, q1_summary)
        st.update(page_id=page_id, mode="cluster", selected_clusters=[])
        # Ë¶ÅÁ¥ÑË°®Á§∫
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=f"üîπ„ÅÇ„Å™„Åü„ÅÆË¶ÅÁ¥ÑÔºö\n{q1_summary}\n\n"
                     "ÂæåÊÇî„Åó„Å™„ÅÑ„Åü„ÇÅ„Å´ÈáçË¶Å„Å†„Å®ÊÄù„ÅÜ‰æ°ÂÄ§Ë¶≥„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑÔºà2„Å§„Åæ„ÅßÔºâ",
                quick_reply=QuickReply(items=[
                    QuickReplyButton(action=MessageAction(label=cl, text=f"„ÇØ„É©„Çπ„Çø:{cl}"))
                    for cl in CLUSTER_LABELS
                ])
            )
        )
        return True

    # 3) „ÇØ„É©„Çπ„ÇøÈÅ∏ÊäûÔºà„Éï„Ç£„É´„ÇøÔºâ--------------------------
    if text.startswith("„ÇØ„É©„Çπ„Çø:") and st.get("mode") == "cluster":
        sel = text.replace("„ÇØ„É©„Çπ„Çø:", "")
        if sel not in CLUSTER_LABELS or sel in st["selected_clusters"]:
            return True
        st["selected_clusters"].append(sel)
        if len(st["selected_clusters"]) < 2:
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(
                    text=f"„ÇÇ„ÅÜ1„Å§ÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑÔºà{','.join(st['selected_clusters'])}Ôºâ",
                    quick_reply=QuickReply(items=[
                        QuickReplyButton(action=MessageAction(label=cl, text=f"„ÇØ„É©„Çπ„Çø:{cl}"))
                        for cl in CLUSTER_LABELS if cl not in st["selected_clusters"]
                    ])
                )
            )
            return True
        values = sum([CLUSTERS[c] for c in st["selected_clusters"]], [])
        st.update(pair_vals=values, pair_scores={v:0 for v in values},
                  pairs=build_pairs(values, MAX_PAIRWISE), p_idx=0, mode="pairwise")
        i, j = st["pairs"][0]
        a, b = values[i], values[j]
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=f"„Å©„Å°„Çâ„Åå„Çà„ÇäÂ§ß‰∫ãÔºü\nA: {a}\nB: {b}",
                quick_reply=QuickReply(items=[
                    QuickReplyButton(action=MessageAction(label=f"A:{a}", text=f"„Éö„Ç¢:{a}")),
                    QuickReplyButton(action=MessageAction(label=f"B:{b}", text=f"„Éö„Ç¢:{b}")),
                ])
            )
        )
        return True

    # „Éñ„É≠„ÉÉ„ÇØÈü≥Â£∞ÂÖ•Âäõ
    if st.get("mode") in ["cluster", "pairwise", "cardsort"]:
        if is_audio:
            line_bot_api.reply_message(event.reply_token,
                TextSendMessage("„Åì„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„ÅØ„Éú„Çø„É≥„ÅßÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ"))
            return True

    # 4) „Éö„Ç¢„ÉØ„Ç§„Ç∫ÂõûÁ≠î ----------------------------------
    if text.startswith("„Éö„Ç¢:") and st.get("mode") == "pairwise":
        val = text.replace("„Éö„Ç¢:", "")
        if val in st["pair_scores"]:
            st["pair_scores"][val] += 1
        st["p_idx"] += 1
        if st["p_idx"] < len(st["pairs"]):
            i, j = st["pairs"][st["p_idx"]]
            a, b = st["pair_vals"][i], st["pair_vals"][j]
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(
                    text=f"„Å©„Å°„Çâ„Åå„Çà„ÇäÂ§ß‰∫ãÔºü\nA: {a}\nB: {b}",
                    quick_reply=QuickReply(items=[
                        QuickReplyButton(action=MessageAction(label=f"A:{a}", text=f"„Éö„Ç¢:{a}")),
                        QuickReplyButton(action=MessageAction(label=f"B:{b}", text=f"„Éö„Ç¢:{b}")),
                    ])
                )
            )
        else:
            top9 = sorted(st["pair_scores"], key=st["pair_scores"].get, reverse=True)[:9]
            st.update(cards=top9, mode="cardsort")
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(
                    text="‰∏ÄÁï™Â§ß‰∫ã„Å†„Å®ÊÄù„ÅÜ‰æ°ÂÄ§Ë¶≥„Çí1„Å§ÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ",
                    quick_reply=QuickReply(items=[
                        QuickReplyButton(action=MessageAction(label=card, text=f"„Ç´„Éº„Éâ:{card}"))
                        for card in top9
                    ])
                )
            )
        return True

    # 5) „Ç´„Éº„Éâ„ÇΩ„Éº„ÉàÔºà1Êûö„Çø„ÉÉ„ÉóÔºâ------------------------
    if text.startswith("„Ç´„Éº„Éâ:") and st.get("mode") == "cardsort":
        card = text.replace("„Ç´„Éº„Éâ:", "")
        if card not in st["cards"]:
            return True

        progress[uid]["latest_value"] = card
        st.update(most=card, mode="q2_reason")
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(text=f"„Å™„Åú„Äå{card}„Äç„ÇíÈÅ∏„Å≥„Åæ„Åó„Åü„ÅãÔºüÁêÜÁî±„ÇíÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        )
        return True

    # 6) ÁêÜÁî±ÂÖ•Âäõ ‚Üí Notion Q2 ‰øùÂ≠ò ------------------------
    if st.get("mode") == "q2_reason":
        summary = summarize(f"{st['most']}ÔºàÁêÜÁî±Ôºö{text}Ôºâ")
        if st.get("page_id"):
            update_notion_row(st["page_id"], "Q2_Summary", summary)
        st.update(mode="after", step=2)
        # Ë¶ÅÁ¥ÑË°®Á§∫
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=f"üîπ„ÅÇ„Å™„Åü„ÅÆË¶ÅÁ¥ÑÔºö\n{summary}\n\n„ÅÇ„Å™„Åü„ÅÆÊúÄÈáçË¶Å‰æ°ÂÄ§Ë¶≥„ÅØ„Äå{st['most']}„Äç„Åß„ÅôÔºÅ\n\nÊ¨°„Å∏ÈÄ≤„Åø„Åæ„Åô\n\n{LIFE5_QUESTIONS[2]}"
            )
        )
        return True

    # 7) Q3„ÄúQ5 ------------------------------------------
    if st.get("mode") == "after":
        step = st["step"]
        if st.get("page_id"):
            summary = summarize(text)
            update_notion_row(st["page_id"], f"Q{step+1}_Summary", summary)
        else:
            summary = summarize(text)
        if step + 1 == 5:
            progress[uid]["latest_mission"] = text
        if step + 1 < len(LIFE5_QUESTIONS):
            st["step"] += 1
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(
                    text=f"üîπ„ÅÇ„Å™„Åü„ÅÆË¶ÅÁ¥ÑÔºö\n{summary}\n\n{LIFE5_QUESTIONS[step+1]}"
                )
            )
        else:
            line_bot_api.reply_message(event.reply_token, TextSendMessage(
                text=f"üîπ„ÅÇ„Å™„Åü„ÅÆË¶ÅÁ¥ÑÔºö\n{summary}\n\n‚úÖ „Åô„Åπ„Å¶ÂõûÁ≠î„Åó„Åæ„Åó„Åü„ÄÇ„ÅÇ„Çä„Åå„Å®„ÅÜÔºÅ"))
        return True

    return False  # Êú™Âá¶ÁêÜ

# ---------- LINE „Éè„É≥„Éâ„É© ----------
@handler.add(MessageEvent, message=TextMessage)
def handle_text(event):
    uid  = event.source.user_id
    text = event.message.text.strip()

    # ----- „Åì„Åì„Åã„Çâmemo„Éï„É≠„Éº -----
    # 1. memo„Éú„Çø„É≥
    if text == "memo":
        memo_state[uid] = {"step": "mode_select"}
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text="‰Ωï„Çí„Åó„Åæ„Åô„ÅãÔºü",
                quick_reply=QuickReply(
                    items=[
                        QuickReplyButton(action=MessageAction(label="„É°„É¢", text="„É°„É¢")),
                        QuickReplyButton(action=MessageAction(label="Âëº„Å≥Âá∫„Åó", text="Âëº„Å≥Âá∫„Åó")),
                        QuickReplyButton(action=MessageAction(label="„Çø„Ç§„Éû„Éº", text="„Çø„Ç§„Éû„Éº")),
                    ]
                )
            )
        )
        return

    # 2. „Äå„É°„É¢„ÄçÈÅ∏Êäû
    if memo_state.get(uid, {}).get("step") == "mode_select" and text == "„É°„É¢":
        memo_state[uid]["step"] = "category_select"
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text="„Ç´„ÉÜ„Ç¥„É™„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ",
                quick_reply=QuickReply(
                    items=[
                        QuickReplyButton(action=MessageAction(label=cat, text=cat))
                        for cat in CATEGORY_BLOCK_IDS.keys()
                    ]
                )
            )
        )
        return

    # 3. „Ç´„ÉÜ„Ç¥„É™ÈÅ∏Êäû
    if memo_state.get(uid, {}).get("step") == "category_select":
        category = text
        memo_state[uid]["category"] = category

        # „Äå„Ç¢„Ç§„Éá„Ç¢„Äç„ÅÆÂ†¥Âêà„ÅØ„Çµ„Éñ„Ç´„ÉÜ„Ç¥„É™ÈÅ∏Êäû
        if category == "„Ç¢„Ç§„Éá„Ç¢":
            memo_state[uid]["step"] = "subcategory_select"
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(
                    text="„Å©„Å°„Çâ„ÅÆ„Ç¢„Ç§„Éá„Ç¢„Åß„Åô„ÅãÔºü",
                    quick_reply=QuickReply(
                        items=[
                            QuickReplyButton(action=MessageAction(label="‰ªï‰∫ã", text="‰ªï‰∫ã")),
                            QuickReplyButton(action=MessageAction(label="„Éó„É©„Ç§„Éô„Éº„Éà", text="„Éó„É©„Ç§„Éô„Éº„Éà")),
                        ]
                    )
                )
            )
            return

        # „Åù„Çå‰ª•Â§ñ„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÅØ„Åù„ÅÆ„Åæ„ÅæÂÜÖÂÆπÂÖ•Âäõ
        memo_state[uid]["step"] = "content_input"
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage("ÂÜÖÂÆπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
        )
        return

    # „Çµ„Éñ„Ç´„ÉÜ„Ç¥„É™ÈÅ∏Êäû
    if memo_state.get(uid, {}).get("step") == "subcategory_select":
        subcategory = text
        memo_state[uid]["subcategory"] = subcategory
        memo_state[uid]["step"] = "content_input"
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage("ÂÜÖÂÆπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
        )
        return

    # ÂÜÖÂÆπÂÖ•Âäõ
    if memo_state.get(uid, {}).get("step") == "content_input":
        category = memo_state[uid].get("category")
        subcategory = memo_state[uid].get("subcategory")
        content = text
        add_memo_to_notion(category, content, subcategory)
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage("„É°„É¢„Çí‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ")
        )
        memo_state.pop(uid, None)
        return
    # ----- „Åì„Åì„Åæ„Åßmemo„Éï„É≠„Éº -----

    # Review„Éï„É≠„ÉºÂÑ™ÂÖà
    if review_flow(uid, text, event, is_audio=False):
        return
    # Life5„Éï„É≠„Éº
    if not life5_flow(uid, text, event, is_audio=False):
        line_bot_api.reply_message(event.reply_token, TextSendMessage("„Åù„ÅÆÊìç‰Ωú„ÅØÁèæÂú®„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Åß„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ"))

@handler.add(MessageEvent, message=AudioMessage)
def handle_audio(event):
    uid = event.source.user_id
    try:
        mid = event.message.id
        audio = line_bot_api.get_message_content(mid)
        with tempfile.NamedTemporaryFile(suffix=".m4a", delete=False) as tmp:
            for c in audio.iter_content(): tmp.write(c); tmp.flush()
            with open(tmp.name, "rb") as f:
                txt = client.audio.transcriptions.create(model="whisper-1", file=f).text.strip()

        if memo_state.get(uid):
            # memo„ÅÆÈÄ≤Ë°åÁä∂Ê≥Å„Å´„Çà„Å£„Å¶ÂàÜÂ≤ê„Åï„Åõ„Çã
            # „Åü„Å®„Åà„Å∞„ÄåÂÜÖÂÆπÂÖ•ÂäõÂæÖ„Å°„Äç„Å™„ÇâÈü≥Â£∞„ÉÜ„Ç≠„Çπ„Éà„Çí„Åù„ÅÆ„Åæ„ÅæÂÖ•„Çå„Çã
            if memo_state[uid].get("step") == "content_input":
                category = memo_state[uid].get("category", "Êú™ÂàÜÈ°û")
                subcategory = memo_state[uid].get("subcategory")
                content = txt
                add_memo_to_notion(category, content, subcategory)
                line_bot_api.reply_message(
                    event.reply_token,
                    TextSendMessage("„É°„É¢„Çí‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅÔºàÈü≥Â£∞ÂÖ•ÂäõÔºâ")
                )
                memo_state.pop(uid, None)
                return
            else:
                # „Åù„Çå‰ª•Â§ñ„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Åß„ÅØÊú™ÂØæÂøú
                line_bot_api.reply_message(
                    event.reply_token,
                    TextSendMessage("Èü≥Â£∞„ÅØÂÜÖÂÆπÂÖ•Âäõ„ÅÆ„Çø„Ç§„Éü„É≥„Ç∞„Åß„ÅÆ„Åø‰Ωø„Åà„Åæ„Åô„ÄÇ")
                )
                return

        # --- „Åì„Åì„Åß review_flow„ÇíÂÖà„Å´ÈÄö„ÅôÔºÅ ---
        if review_flow(uid, txt, event, is_audio=True):
            return
        # Life5„Éï„É≠„Éº„ÇÇÈÄö„Åô
        if not life5_flow(uid, txt, event, is_audio=True):
            line_bot_api.reply_message(event.reply_token, TextSendMessage("„Åù„ÅÆÊìç‰Ωú„ÅØÁèæÂú®„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Åß„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ"))
    except Exception as e:
        print("Whisper error:", e)
        line_bot_api.reply_message(event.reply_token, TextSendMessage("‚ö†Ô∏è Èü≥Â£∞„ÅÆÊñáÂ≠óËµ∑„Åì„Åó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ"))

import re

# Review„ÅÆÁä∂ÊÖãÁÆ°ÁêÜÔºà„É¶„Éº„Ç∂„Éº„Åî„Å®„Å´ÈÄ≤Êçó„ÇíË®òÈå≤Ôºâ
review_progress = {}  # uid ‚Üí state dict

REVIEW_QUESTIONS = [
    {
        "key": "ValueStar",
        "type": "star",
        "label": "Value‚òÖ „ÅÆÊï¥ÂêàÂ∫¶„Çí 1„Äú5 „ÅÆ‚òÖ„ÅßÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ",
        "stars": [1, 2, 3, 4, 5],
    },
    {
        "key": "ValueReason",
        "type": "star_reason",
        "label": "‚òÖ„Çí{N}„Å´„Åó„ÅüÁêÜÁî±„ÇíÊïô„Åà„Å¶ÔºÅ",
        "choices": ["ÊôÇÈñì„ÅåË∂≥„Çä„Å™„Åã„Å£„Åü", "ÈõÜ‰∏≠„Åß„Åç„Åü", "„Çø„Çπ„ÇØ„ÅåÂ§öÈÅé„Åé„Åü", "ÈÄî‰∏≠„Åß‰∏≠Êñ≠„Åó„Åü", "Ëá™‰ø°„Åå„ÅÇ„Å£„Åü"],
        "allow_free": True,
        "max_length": 50,
    },
    {
        "key": "MissionStar",
        "type": "star",
        "label": "Mission‚òÖ „ÅÆÈÅîÊàêÂ∫¶„Çí 1„Äú5 „ÅÆ‚òÖ„ÅßÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ",
        "stars": [1, 2, 3, 4, 5],
    },
    {
        "key": "MissionReason",
        "type": "star_reason",
        "label": "‚òÖ„Çí{N}„Å´„Åó„ÅüÁêÜÁî±„ÇíÊïô„Åà„Å¶ÔºÅ",
        "choices": ["Ë®àÁîªÈÄö„ÇäÈÄ≤„ÇÅ„Åü", "ÊÄù„Å£„Åü„Çà„ÇäÈõ£„Åó„Åã„Å£„Åü", "ÊôÇÈñì„ÅåË∂≥„Çä„Å™„Åã„Å£„Åü", "ÈõÜ‰∏≠„Åß„Åç„Åü", "„É¢„ÉÅ„Éô„ÅåÈ´ò„Åã„Å£„Åü"],
        "allow_free": True,
        "max_length": 50,
    },
    {
        "key": "Win",
        "type": "text",
        "label": "‰ªäÊó•„ÅÜ„Åæ„Åè„ÅÑ„Å£„ÅüË°åÂãï„ÅØÔºü",
        "max_length": 100,
    },
    {
        "key": "IfThen",
        "type": "text",
        "label": "Ê¨°„ÅØ„Å©„ÅÜÊîπÂñÑ„ÉªËá™ÂãïÂåñ„Åô„ÇãÔºüif-then ÂΩ¢Âºè„Åß 1 Ë°å„Åß",
        "max_length": 100,
    },
    {
        "key": "Pride",
        "type": "text",
        "label": "Ë™á„Çä„ÇíÊÑü„Åò„ÅüÁû¨Èñì„ÅØÔºü",
        "max_length": 100,
    },
    {
        "key": "Gratitude",
        "type": "text",
        "label": "ÊÑüË¨ù„Åó„ÅüÔºè„Åï„Çå„Åü„Åì„Å®„ÅØÔºü",
        "max_length": 100,
    },
    {
        "key": "EmotionTag",
        "type": "emotion",
        "label": "ÊúÄ„ÇÇÂº∑„Åã„Å£„ÅüÊÑüÊÉÖ„ÅØÔºü",
        "choices": ["Âñú„Å≥", "ÊÄí„Çä", "ÊÇ≤„Åó„Åø", "È©ö„Åç", "‰∏çÂÆâ"],
        "allow_free": True,
        "max_length": 100,  # ‚Üê50‚Üí100
    },
    {
        "key": "Insight",
        "type": "text",
        "label": "‰ªäÊó•Âæó„ÅüÊ∞ó„Å•„Åç„ÉªÂ≠¶„Å≥„ÅØÔºü",
        "max_length": 100,
    },
    {
        "key": "Tomorrow",
        "type": "text",
        "label": "ÊòéÊó•„ÅÆ MIT „Çí‰∏ÄË®Ä„ÅßÔºü",
        "max_length": 50,
    },
]

def review_flow(uid, text, event, is_audio=False):
    st = review_progress.setdefault(uid, {})
    print(f"[review_flow] uid={uid}, step={st.get('step')}, text='{text}'")
    # --- „É¨„Éì„É•„ÉºÈñãÂßã„Åß‰ªñ„Éï„É≠„Éº„ÅÆÁä∂ÊÖã„ÇíÊ∂àÂéª ---
    if text.lower() == "/review":
        st.clear()
        st["step"] = 0
        st["answers"] = {}

        st["latest_value"] = progress.get(uid, {}).get("latest_value", "")
        st["latest_mission"] = progress.get(uid, {}).get("latest_mission", "")

        progress.pop(uid, None)
        # Êñ∞Ë¶è„Éö„Éº„Ç∏„ÇíNotion„Å´‰ΩúÊàê
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
        page_id = create_review_page(uid, now)
        st["page_id"] = page_id
        ask_review_question(uid, event, 0)
        return True

    if "step" not in st:
        print("[review_flow] step not in st!", st)
        return False  # „Åì„ÅÆ„Éï„É≠„ÉºÂ§ñ

    step = st["step"]
    q = REVIEW_QUESTIONS[step]

    # Èü≥Â£∞ÂÖ•Âäõ„ÅÆË®±ÂèØÂà§ÂÆöÔºàstar_reason„Å®emotion„ÇÇË®±ÂèØÔºâ
    if is_audio and q["type"] not in ("text", "star_reason", "emotion"):
        line_bot_api.reply_message(event.reply_token, TextSendMessage("„Åì„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„ÅØ„Éú„Çø„É≥„ÅßÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ"))
        return True

    # starÂûãÔºà‚òÖÈÅ∏ÊäûÔºâ
    if q["type"] == "star":
        if re.fullmatch(r"[‚òÖ‚òÜ]{1,5}", text) or (text.isdigit() and 1 <= int(text) <= 5):
            val = str(text.count("‚òÖ")) if "‚òÖ" in text else str(text)
            st["answers"][q["key"]] = val

            # ‚òÖ ValueStar„ÅÆ„Å®„Åç„Å†„ÅëNotion„Éö„Éº„Ç∏Êñ∞Ë¶è‰ΩúÊàê
            if q["key"] == "ValueStar" and "page_id" not in st:
                now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
                page_id = create_review_page(uid, now)
                st["page_id"] = page_id

            # --- „Åì„Åì„ÅßÂç≥ÊôÇ‰øùÂ≠ò ---
            if "page_id" in st and st["page_id"]:
                update_notion_row(st["page_id"], q["key"], val)

            st["step"] += 1
            ask_review_question(uid, event, st["step"], prev_star=val)
            return True
        # QuickReply‰ª•Â§ñ„ÅØÂºæ„Åè
        star_labels = [f"{'‚òÖ'*n}{'‚òÜ'*(5-n)}" for n in range(1,6)]
        if text not in star_labels and text not in [str(n) for n in range(1,6)]:
            line_bot_api.reply_message(event.reply_token, TextSendMessage("1„Äú5 „ÅÆ‚òÖ„ÅßÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ"))
            return True

    # star_reasonÂûã
    elif q["type"] == "star_reason":
        # Èü≥Â£∞ÊôÇ„ÅØË¶ÅÁ¥Ñ„Éª100Â≠óÂà∂Èôê
        if is_audio:
            text = summarize(text)[:100]
        if text in q["choices"]:
            st["answers"][q["key"]] = text
        elif len(text) <= 100:
            st["answers"][q["key"]] = text
        else:
            # Ëá™ÂãïË¶ÅÁ¥ÑÔºÜ100Â≠ó‰ª•ÂÜÖ„Åß‰øùÂ≠ò
            text = summarize(text)[:100]
            st["answers"][q["key"]] = text
        if "page_id" in st and st["page_id"]:
            update_notion_row(st["page_id"], q["key"], text)
        st["step"] += 1
        ask_review_question(uid, event, st["step"])
        return True

    # emotionÂûãÔºàÈÅ∏ÊäûÔºã‰ªªÊÑèË£úË∂≥Ôºâ
    elif q["type"] == "emotion":
        if "EmotionTag_main" not in st:
            if text in q["choices"]:
                st["EmotionTag_main"] = text
                line_bot_api.reply_message(
                    event.reply_token,
                    TextSendMessage(
                        text="ÂøÖË¶Å„Å™„Çâ100Â≠ó‰ª•ÂÜÖ„ÅßÊÑüÊÉÖ„ÅÆË£úË∂≥„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà„Çπ„Ç≠„ÉÉ„ÉóÂèØÔºâ",
                        quick_reply=QuickReply(items=[
                            QuickReplyButton(action=MessageAction(label="„Çπ„Ç≠„ÉÉ„Éó", text="„Çπ„Ç≠„ÉÉ„Éó"))
                        ])
                    )
                )
                if "page_id" in st and st["page_id"]:
                    update_notion_row(st["page_id"], q["key"], text)
                return True
            else:
                line_bot_api.reply_message(
                    event.reply_token,
                    TextSendMessage(
                        text="ÊÑüÊÉÖ„Çø„Ç∞„ÇíÔºë„Å§ÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ",
                        quick_reply=QuickReply(items=[
                            QuickReplyButton(action=MessageAction(label=tag, text=tag))
                            for tag in q["choices"]
                        ])
                    )
                )
                return True
        # Ë£úË∂≥Ë™¨ÊòéÔºà„Çπ„Ç≠„ÉÉ„ÉóorËá™Áî±ÂÖ•ÂäõÔºâ„Åì„Åì„ÇÇÈü≥Â£∞„Éª100Â≠óÂà∂Èôê
        if text == "„Çπ„Ç≠„ÉÉ„Éó":
            st["answers"][q["key"]] = st.pop("EmotionTag_main")
            st["answers"]["EmotionNote"] = ""
            if "page_id" in st and st["page_id"]:
                update_notion_row(st["page_id"], q["key"], st["answers"][q["key"]])
                update_notion_row(st["page_id"], "EmotionNote", "")
            st["step"] += 1
            ask_review_question(uid, event, st["step"])
            return True
        # „Åì„Åì„ÅßÈü≥Â£∞ÂÖ•Âäõ„ÇÑÈï∑Êñá„ÇÇË¶ÅÁ¥Ñ100Â≠ó
        note = summarize(text)[:100] if (is_audio or len(text) > 100) else text
        st["answers"][q["key"]] = st.pop("EmotionTag_main")
        st["answers"]["EmotionNote"] = note
        if "page_id" in st and st["page_id"]:
            update_notion_row(st["page_id"], q["key"], st["answers"][q["key"]])
            update_notion_row(st["page_id"], "EmotionNote", note)
        st["step"] += 1
        ask_review_question(uid, event, st["step"])
        return True

    # textÂûã
    elif q["type"] == "text":
        # Èü≥Â£∞„Åæ„Åü„ÅØ100Â≠óË∂Ö‚ÜíËá™ÂãïË¶ÅÁ¥Ñ
        if is_audio or len(text) > q["max_length"]:
            text = summarize(text)[:q["max_length"]]
        st["answers"][q["key"]] = text
        if "page_id" in st and st["page_id"]:
            update_notion_row(st["page_id"], q["key"], text)
        st["step"] += 1
        if st["step"] >= len(REVIEW_QUESTIONS):
            review_progress.pop(uid, None)
            line_bot_api.reply_message(event.reply_token, TextSendMessage("‚úÖ Review„ÅÆÂÖ•Âäõ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ„ÅÇ„Çä„Åå„Å®„ÅÜÔºÅ"))
            return True
        ask_review_question(uid, event, st["step"])
        return True

    # ÁµÇ‰∫ÜÂà§ÂÆö
    if st["step"] >= len(REVIEW_QUESTIONS):
        save_review_to_notion(uid, st["answers"])
        review_progress.pop(uid, None)
        line_bot_api.reply_message(event.reply_token, TextSendMessage("‚úÖ Review„ÅÆÂÖ•Âäõ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ„ÅÇ„Çä„Åå„Å®„ÅÜÔºÅ"))
        return True

    return False

def ask_review_question(uid, event, step, prev_star=None):
    if step >= len(REVIEW_QUESTIONS):
        return
    q = REVIEW_QUESTIONS[step]

    user_st = review_progress.get(uid, {})
    latest_value = user_st.get("latest_value", "")
    latest_mission = user_st.get("latest_mission", "")

    # ValueStar: ‰æ°ÂÄ§Ë¶≥
    if q["key"] == "ValueStar":
        label = (
            f"‰ªäÊó•„ÅÆ‰æ°ÂÄ§Ë¶≥„ÅØ„Äå{latest_value}„Äç„Åß„Åó„Åü„ÄÇValue‚òÖ „ÅÆÊï¥ÂêàÂ∫¶„Çí 1„Äú5 „ÅÆ‚òÖ„ÅßÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ"
            if latest_value else "Value‚òÖ „ÅÆÊï¥ÂêàÂ∫¶„Çí 1„Äú5 „ÅÆ‚òÖ„ÅßÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ"
        )
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=label,
                quick_reply=QuickReply(items=[
                    QuickReplyButton(action=MessageAction(
                        label=f"{'‚òÖ'*n}{'‚òÜ'*(5-n)}", text=str(n))) for n in q["stars"]
                ])
            )
        )
        return

    # MissionStar: „Éü„ÉÉ„Ç∑„Éß„É≥
    if q["key"] == "MissionStar":
        label = (
            f"‰ªäÊó•„ÅÆ„Éü„ÉÉ„Ç∑„Éß„É≥„ÅØ„Äå{latest_mission}„Äç„Åß„Åó„Åü„ÄÇMission‚òÖ „ÅÆÈÅîÊàêÂ∫¶„Çí 1„Äú5 „ÅÆ‚òÖ„ÅßÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ"
            if latest_mission else "Mission‚òÖ „ÅÆÈÅîÊàêÂ∫¶„Çí 1„Äú5 „ÅÆ‚òÖ„ÅßÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ"
        )
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=label,
                quick_reply=QuickReply(items=[
                    QuickReplyButton(action=MessageAction(
                        label=f"{'‚òÖ'*n}{'‚òÜ'*(5-n)}", text=str(n))) for n in q["stars"]
                ])
            )
        )
        return
    # Ôºà‰ª•‰∏ãÁï•Ôºöstar_reason, emotion, textÂûã„ÅØÁèæÁä∂„ÅÆ„Åæ„Åæ„ÅßOKÔºâ

    # ‚òÖÁêÜÁî±
    elif q["type"] == "star_reason":
        prev_n = prev_star if prev_star is not None else ""
        label = q["label"].replace("{N}", prev_n)
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=label,
                quick_reply=QuickReply(items=[
                    QuickReplyButton(action=MessageAction(label=choice, text=choice))
                    for choice in q["choices"]
                ])
            )
        )
        return
    # emotion
    elif q["type"] == "emotion":
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=q["label"],
                quick_reply=QuickReply(items=[
                    QuickReplyButton(action=MessageAction(label=tag, text=tag)) for tag in q["choices"]
                ])
            )
        )
        return
    # „ÉÜ„Ç≠„Çπ„Éà
    else:
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=q["label"]))

def save_review_to_notion(uid, answers):
    print("[save_review_to_notion] DBID:", os.getenv("NOTION_REVIEW_DBID", "Review_Log"))
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    data = {
        "parent": {"database_id": os.getenv("NOTION_REVIEW_DBID", "Review_Log")},
        "properties": {
            "Date":          {"title": [{"text": {"content": now}}]},
            "UserID":        {"rich_text": [{"text": {"content": uid}}]},
            "Value‚òÖ":        {"rich_text": [{"text": {"content": answers.get("ValueStar", "")}}]},
            "Value reason":  {"rich_text": [{"text": {"content": answers.get("ValueReason", "")}}]},
            "Mission‚òÖ":      {"rich_text": [{"text": {"content": answers.get("MissionStar", "")}}]},
            "Mission reason":{"rich_text": [{"text": {"content": answers.get("MissionReason", "")}}]},
            "Win":           {"rich_text": [{"text": {"content": answers.get("Win", "")}}]},
            "If-Then":       {"rich_text": [{"text": {"content": answers.get("IfThen", "")}}]},
            "Pride":         {"rich_text": [{"text": {"content": answers.get("Pride", "")}}]},
            "Gratitude":     {"rich_text": [{"text": {"content": answers.get("Gratitude", "")}}]},
            "EmotionTag":    {"rich_text": [{"text": {"content": answers.get("EmotionTag", "")}}]},
            "EmotionNote":   {"rich_text": [{"text": {"content": answers.get("EmotionNote", "")}}]},
            "Insight":       {"rich_text": [{"text": {"content": answers.get("Insight", "")}}]},
            "TomorrowMIT":   {"rich_text": [{"text": {"content": answers.get("Tomorrow", "")}}]},
        }
    }
    r = requests.post(
        "https://api.notion.com/v1/pages",
        headers={
            "Authorization": f"Bearer {NOTION_TOKEN}",
            "Content-Type": "application/json",
            "Notion-Version": "2022-06-28",
        },
        json=data,
    )
    print("[Notion review create]", r.status_code, r.text)

if __name__ == "__main__":
    app.run(port=5000)
